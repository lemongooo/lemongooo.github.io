---
title: 商城接口自动化项目介绍（架构+测试用例+测试报告）
description: '基于pytest框架的接口自动化项目介绍.'
publishDate: 2025-10-09
tags:
  - pytest
  - 接口自动化
language: '中文'
heroImage: { src: './heroimage.png', color: '#ffc4c0ff' }
---
# 电商平台接口自动化测试框架实战

## 📋 项目介绍

该项目是一个**在线购物商城网站**的接口自动化测试框架,覆盖用户注册、登录、商品管理、下单、支付等核心功能。采用 **Python + Pytest + YAML** 技术栈,实现了数据驱动测试、接口参数关联、多种断言模式等企业级特性。

### 核心特性

- ✅ **数据驱动测试** - YAML配置与代码分离,实现用例解耦
- ✅ **接口参数关联** - 自动提取和传递接口间依赖参数
- ✅ **多维度断言** - 支持响应断言、状态码断言、数据库断言
- ✅ **POM设计模式** - 分离用例层与驱动层,提升可维护性
- ✅ **全流程测试** - 支持用户管理、商品下单完整业务场景
- ✅ **可视化报告** - 集成 Allure 生成详细测试报告

### 技术栈

```text
测试框架: Pytest
请求库: Requests
数据驱动: YAML + Parametrize
断言引擎: 自定义多模式断言
数据库: SQLAlchemy + PyMySQL
报告工具: Allure
持续集成: Jenkins + Linux
数据提取: JSONPath + 正则表达式
```

---

## 🏗️ 项目架构

### 目录结构

```plaintext
automaticAPI/
├── base/                       # 基础封装层
│   ├── apiutil.py             # 单接口用例处理(驱动层)
│   └── generateId.py          # 报告ID生成器
│
├── common/                     # 公共方法层
│   ├── sendrequest.py         # HTTP请求统一封装
│   ├── assertions.py          # 断言引擎
│   ├── debugtalk.py           # 动态参数辅助函数
│   ├── readyaml.py            # YAML数据读取
│   └── recordlog.py           # 日志记录
│
├── conf/                       # 配置管理
│   ├── config.ini             # 环境配置(host/数据库)
│   └── operationConfig.py     # 配置读取工具
│
├── data/                       # 数据存储
│   └── extract.yaml           # 接口参数提取存储
│
├── testcase/                   # 测试用例层
│   ├── Single interface/      # 单接口测试用例
│   │   ├── addUser.yaml       # 新增用户
│   │   ├── updateUser.yaml    # 修改用户
│   │   ├── deleteUser.yaml    # 删除用户
│   │   └── queryUser.yaml     # 查询用户
│   │
│   └── ProductManager/        # 商品管理用例
│       ├── getProductList.yaml # 商品列表
│       ├── commitOrder.yaml    # 提交订单
│       └── orderPay.yaml       # 订单支付
│
├── logs/                       # 测试日志
├── report/                     # 测试报告
│   ├── temp/                  # Allure原始数据
│   └── html/                  # HTML报告
│
├── test_debug_api.py          # 用户管理测试入口
├── test_productList.py        # 商品管理测试入口
├── conftest.py                # Pytest全局配置
├── pytest.ini                 # Pytest配置文件
└── requirements.txt           # 项目依赖
```

### POM架构设计

**架构流程:**

```
测试用例层 (test_*.py)
    ↓ 调用
驱动层 (RequestBase)
    ↓ 读取
数据层 (YAML配置)
    ↓ 动态替换
辅助函数 (DebugTalk)
    ↓ 发送请求
请求封装 (SendRequest)
    ↓ HTTP请求
服务器接口
    ↓ 响应处理
结果处理
    ├─ 参数提取 → extract.yaml
    └─ 断言验证 → Assertions
           ↓
    Allure测试报告
```

**三层架构说明:**

| 层级 | 文件/类 | 职责 | 优势 |
|-----|---------|------|------|
| **用例层** | test_debug_api.py<br/>test_productList.py | 定义测试场景和执行流程 | 专注业务逻辑,易于维护 |
| **驱动层** | apiutil.py<br/>RequestBase类 | 封装请求、断言、参数替换 | 统一处理,代码复用 |
| **数据层** | addUser.yaml<br/>commitOrder.yaml | 存储接口配置和测试数据 | 用例与数据分离,易扩展 |

---

## ⚙️ 环境配置

### 1. 依赖安装

```bash
pip install -r requirements.txt
```

### 2. 核心依赖清单

核心依赖包:

- **pytest** - 测试框架
- **allure-pytest** - 报告生成
- **requests** - HTTP请求
- **PyYAML** - YAML解析
- **jsonpath** - JSON提取
- **PyMySQL** - MySQL操作
- **SQLAlchemy** - ORM框架
- **faker** - 测试数据生成

### 3. Pytest配置

```ini
[pytest]
python_files = test_*.py
python_classes = Test*
python_functions = test
```

### 4. 环境配置

```ini
[api_envi]
host = http://127.0.0.1:8787

[MYSQL]
host = localhost
port = 3306
username = root
password = 12345
database = testdb
```

---

## 🔧 核心功能实现

### 1. YAML数据驱动

#### 用例模板结构

```yaml
- baseInfo:                           # 接口基础信息
    api_name: 接口名称
    url: /api/path
    method: POST                      # 请求方法
    header:                           # 请求头
      Content-Type: application/json
  
  testCase:                           # 测试用例列表
    - case_name: 用例名称
      json:                           # 请求体(JSON格式)
        param1: value1
        param2: ${get_extract_data(token)}  # 动态参数
      
      validation:                     # 断言配置
        - contains: {'status_code': 200}
        - eq: {'error_code': '0000'}
      
      extract:                        # 参数提取
        userId: $.data.userId
```

#### 实战案例1: 用户管理

```yaml
- baseInfo:
    api_name: 新增用户
    url: /dar/user/addUser
    method: POST
    header:
      Content-Type: application/x-www-form-urlencoded;charset=UTF-8
  
  testCase:
    - case_name: 正常新增用户
      data:
        username: testadduser
        password: tset6789890
        role_id: 123456789
        dates: '2023-12-31'
        phone: 13800000000
        token: ${get_extract_data(token)}    # 依赖登录接口返回的token
      validation:
        - contains: {'status_code': 200}
        - contains: {'msg': '新增成功'}
    
    - case_name: 无效新增·缺少token
      data:
        username: testadduser
        password: tset6789890
        role_id: 123456789
        token:                                # token为空
      validation:
        - contains: {'msg': '新增失败'}
    
    - case_name: 无效新增·缺少必填参数
      data:
        password: tset6789890
        role_id: 123456789
        # 缺少username参数
      validation:
        - contains: {'msg': '新增失败'}
```

#### 实战案例2: 电商下单流程

```yaml
- baseInfo:
    api_name: 提交订单
    url: /coupApply/cms/placeAnOrder
    method: post
    header:
      Content-Type: application/json;charset=UTF-8
  
  testCase:
    - case_name: 提交订单
      json:
        goods_id: ${get_extract_data(goodsId,0)}      # 从商品列表提取
        number: 2
        propertyChildIds: '2:9'
        price: '128'
        consignee_info: 
          name: "张三"
          phone: 13800000000
          address: "北京市海淀区西三环北路74号"
      
      validation:
        - eq: {'message': '提交订单成功'}
        - eq: {'error_code': '0000'}
      
      extract:                                        # 提取订单号供支付接口使用
        orderNumber: $.orderNumber
        userId: $.userId
```

```yaml
- baseInfo:
    api_name: 订单支付
    url: /coupApply/cms/orderPay
    method: post
  
  testCase:
    - case_name: 订单支付
      json:
        orderNumber: ${get_extract_data(orderNumber)}  # 依赖提交订单返回的订单号
        userId: ${get_extract_data(userId)}
        timeStamp: ${timestamp()}                      # 动态时间戳
      
      validation:
        - contains: {'message': '订单支付成功'}
        - contains: {'error_code': '0000'}
```

---

### 2. 接口参数关联

#### 参数提取机制

**支持两种提取方式:**

```yaml
# 方式1: JSONPath提取(推荐)
extract:
  token: $.data.token                    # 提取单个值
  userId: $.data.user.id

# 方式2: 正则表达式提取
extract:
  token: '"token": "(.*?)"'              # 正则匹配

# 方式3: 列表数据提取
extract_list:
  goodsIds: $.goodsList[*].goodsId       # 提取所有商品ID
```

#### 参数使用

```yaml
# 在后续接口中使用提取的参数
json:
  token: ${get_extract_data(token)}           # 获取单个值
  goods_id: ${get_extract_data(goodsIds,0)}   # 获取列表第0个元素
```

#### 核心代码实现

```python
class RequestBase:
    """请求基础类 - 驱动层核心"""
    
    def extract_data(self, testcase_extract, response):
        """
        提取接口响应参数并存储到extract.yaml
        
        Args:
            testcase_extract: YAML中的extract配置
            response: 接口响应文本
        """
        for key, value in testcase_extract.items():
            # JSONPath提取
            if value.startswith('$.'):
                ext_data = jsonpath.jsonpath(
                    json.loads(response), value
                )
                if ext_data:
                    # 存储到extract.yaml
                    self.write_extract_yaml({key: ext_data[0]})
                    logs.info(f"参数提取成功: {key} = {ext_data[0]}")
            
            # 正则表达式提取
            else:
                ext_list = re.search(value, response)
                if ext_list:
                    self.write_extract_yaml({key: ext_list.group(1)})
    
    def replace_data(self, data):
        """
        动态替换YAML中的${函数名(参数)}格式
        
        示例:
            ${get_extract_data(token)} → 从extract.yaml读取token值
            ${timestamp()} → 生成当前时间戳
            ${random_phone()} → 生成随机手机号
        """
        pattern = r'\$\{(.+?)\}'
        
        while re.search(pattern, str(data)):
            res_value = re.search(pattern, str(data))
            func_name = res_value.group(1)
            
            # 执行debugtalk.py中的函数
            value = eval(func_name)
            
            # 替换原始数据
            data = re.sub(pattern, str(value), str(data), count=1)
        
        return data
```

---

### 3. 多模式断言引擎

#### 支持的断言类型

| 断言模式 | YAML配置示例 | 说明 | 使用场景 |
|---------|-------------|------|---------|
| **contains** | `contains: {'msg': '成功'}` | 检查响应中是否包含某值 | 通用断言 ⭐⭐⭐⭐⭐ |
| **eq** | `eq: {'error_code': '0000'}` | 精确匹配字段值 | 状态码/错误码验证 ⭐⭐⭐⭐ |
| **ne** | `ne: {'status': 'failed'}` | 验证字段不等于某值 | 反向验证 ⭐⭐⭐ |
| **db** | `db: SELECT * FROM users WHERE id=1` | 数据库数据验证 | 数据一致性检查 ⭐⭐⭐⭐ |

#### 断言实现

```python
class Assertions:
    """断言引擎"""
    
    def contains_assert(self, expected, response, status_code):
        """
        包含断言 - 检查响应中是否包含期望值
        
        Args:
            expected: {'msg': '成功', 'status_code': 200}
            response: 接口响应JSON
            status_code: HTTP状态码
        """
        flag = 0  # 失败标记
        
        for key, value in expected.items():
            if key == "status_code":
                # 断言状态码
                if value != status_code:
                    flag += 1
                    logs.error(f"状态码断言失败: {status_code} != {value}")
            else:
                # 断言响应字段
                resp_list = jsonpath.jsonpath(response, f"$..{key}")
                if value not in resp_list:
                    flag += 1
                    logs.error(f"包含断言失败: {value} 不在 {resp_list}")
        
        return flag
    
    def equal_assert(self, expected, actual, status_code=None):
        """
        相等断言 - 精确匹配字段值
        
        示例:
            expected: {'error_code': '0000'}
            actual: {'error_code': '0000', 'msg': '成功'}
        """
        flag = 0
        common_key = list(expected.keys() & actual.keys())[0]
        
        if actual[common_key] == expected[common_key]:
            logs.info(f"相等断言成功: {actual[common_key]} == {expected[common_key]}")
        else:
            flag += 1
            logs.error(f"相等断言失败: {actual[common_key]} != {expected[common_key]}")
        
        return flag
    
    def assert_mysql_data(self, sql):
        """
        数据库断言 - 验证数据库中的数据
        
        Args:
            sql: SELECT * FROM users WHERE username='testuser'
        """
        conn = ConnectMysql()
        db_value = conn.query_all(sql)
        
        if db_value is not None:
            logs.info(f"数据库断言成功: 查询到 {len(db_value)} 条数据")
            return 0
        else:
            logs.error("数据库断言失败: 未查询到数据")
            return 1
```

#### 断言执行流程

**流程说明:**

```
接口响应
  ↓
解析 validation 配置
  ↓
遍历断言列表
  ↓
判断断言类型
  ├─ contains → 包含断言
  ├─ eq → 相等断言
  ├─ ne → 不相等断言
  └─ db → 数据库断言
       ↓
累计失败标记 flag
  ↓
flag == 0 ?
  ├─ 是 → ✅ 断言成功
  └─ 否 → ❌ 断言失败(抛出异常)
```

---

### 4. 动态参数处理

#### 辅助函数库

```python
import time
import random
from faker import Faker

fake = Faker('zh_CN')

# === 参数提取相关 ===
def get_extract_data(key, index=None):
    """
    从extract.yaml读取提取的参数
    
    Args:
        key: 参数名
        index: 列表索引(可选)
            None - 返回单个值
            0,1,2... - 返回列表指定位置的值
            -1 - 返回所有值的字符串(逗号分隔)
            -2 - 返回所有值的列表
    
    示例:
        goodsIds = ['123', '456', '789']
        get_extract_data('goodsIds', 0)  → '123'
        get_extract_data('goodsIds', -1) → '123,456,789'
        get_extract_data('goodsIds', -2) → ['123','456','789']
    """
    data = read_extract_yaml(key)
    
    if index is None:
        return data
    elif index == -1:
        return ','.join(data)
    elif index == -2:
        return data
    else:
        return data[index]

# === 时间相关 ===
def timestamp():
    """生成13位时间戳(毫秒)"""
    return int(time.time() * 1000)

def today_zero_stamp():
    """获取今天零点时间戳"""
    today = time.strftime('%Y-%m-%d', time.localtime())
    return int(time.mktime(time.strptime(today, '%Y-%m-%d')))

def get_current_time():
    """获取当前时间字符串: 2025-10-12 15:30:00"""
    return time.strftime('%Y-%m-%d %H:%M:%S', time.localtime())

# === 随机数据生成 ===
def random_phone():
    """生成随机手机号"""
    return fake.phone_number()

def random_name():
    """生成随机姓名"""
    return fake.name()

def random_address():
    """生成随机地址"""
    return fake.address()

def random_email():
    """生成随机邮箱"""
    return fake.email()

def random_id_card():
    """生成随机身份证号"""
    return fake.ssn()

# === 字符串处理 ===
def generate_random_str(length=8):
    """生成指定长度的随机字符串"""
    chars = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789'
    return ''.join(random.choice(chars) for _ in range(length))
```

#### 使用示例

```yaml
testCase:
  - case_name: 注册新用户
    json:
      username: ${random_name()}              # 随机姓名
      phone: ${random_phone()}                # 随机手机号
      email: ${random_email()}                # 随机邮箱
      register_time: ${get_current_time()}    # 当前时间
      timestamp: ${timestamp()}               # 时间戳
```

---

### 5. 请求统一封装

```python
import requests
import allure
from common.recordlog import logs

class SendRequest:
    """HTTP请求统一封装"""
    
    def send_request(self, **kwargs):
        """发送HTTP请求"""
        session = requests.session()
        
        try:
            # 发送请求
            result = session.request(**kwargs)
            
            # 记录日志
            logs.info(f"响应状态码: {result.status_code}")
            logs.info(f"响应内容: {result.text}")
            
            return result
            
        except requests.exceptions.ConnectionError:
            logs.error("连接异常")
            pytest.fail("接口请求失败: 连接异常")
        except requests.exceptions.Timeout:
            logs.error("请求超时")
            pytest.fail("接口请求失败: 请求超时")
    
    def run_main(self, name, url, case_name, header, method, **kwargs):
        """
        请求主入口
        
        Args:
            name: 接口名称
            url: 接口地址
            case_name: 测试用例名称
            header: 请求头
            method: 请求方法(GET/POST)
            **kwargs: 请求参数(params/data/json)
        """
        # 日志记录
        logs.info(f'=' * 100)
        logs.info(f'接口名称: {name}')
        logs.info(f'测试用例: {case_name}')
        logs.info(f'请求地址: {url}')
        logs.info(f'请求方式: {method}')
        
        # Allure报告附件
        if "data" in kwargs or "json" in kwargs:
            allure.attach(
                json.dumps(kwargs, ensure_ascii=False),
                '请求参数',
                allure.attachment_type.TEXT
            )
        
        # 发送请求
        response = self.send_request(
            method=method,
            url=url,
            headers=header,
            timeout=30,
            verify=False,
            **kwargs
        )
        
        return response
```

---

## 📝 测试用例实现

### 1. 用户管理模块

```python
import allure
import pytest
from common.readyaml import get_testcase_yaml
from base.apiutil import RequestBase
from base.generateId import m_id, c_id

@allure.feature(next(m_id) + '用户管理模块')
class TestUserManager:
    
    @allure.story(next(c_id) + "新增用户")
    @pytest.mark.run(order=1)
    @pytest.mark.parametrize('base_info,testcase', 
        get_testcase_yaml("./testcase/Single interface/addUser.yaml"))
    def test_add_user(self, base_info, testcase):
        """测试新增用户接口"""
        allure.dynamic.title(testcase['case_name'])
        RequestBase().specification_yaml(base_info, testcase)
    
    @allure.story(next(c_id) + "修改用户")
    @pytest.mark.run(order=2)
    @pytest.mark.parametrize('base_info,testcase',
        get_testcase_yaml("./testcase/Single interface/updateUser.yaml"))
    def test_update_user(self, base_info, testcase):
        """测试修改用户接口"""
        allure.dynamic.title(testcase['case_name'])
        RequestBase().specification_yaml(base_info, testcase)
    
    @allure.story(next(c_id) + "删除用户")
    @pytest.mark.run(order=3)
    @pytest.mark.parametrize('base_info,testcase',
        get_testcase_yaml("./testcase/Single interface/deleteUser.yaml"))
    def test_delete_user(self, base_info, testcase):
        """测试删除用户接口"""
        allure.dynamic.title(testcase['case_name'])
        RequestBase().specification_yaml(base_info, testcase)
    
    @allure.story(next(c_id) + "查询用户")
    @pytest.mark.run(order=4)
    @pytest.mark.parametrize('base_info,testcase',
        get_testcase_yaml("./testcase/Single interface/queryUser.yaml"))
    def test_query_user(self, base_info, testcase):
        """测试查询用户接口"""
        allure.dynamic.title(testcase['case_name'])
        RequestBase().specification_yaml(base_info, testcase)
```

### 2. 商品下单全流程

```python
import allure
import pytest
from base.apiutil import RequestBase
from common.readyaml import get_testcase_yaml
from base.generateId import m_id, c_id

@allure.feature(next(m_id) + '商品管理模块')
class TestProductFlow:
    
    @allure.story(next(c_id) + "获取商品列表")
    @pytest.mark.run(order=1)
    @pytest.mark.parametrize('base_info,testcase',
        get_testcase_yaml('./testcase/ProductManager/getProductList.yaml'))
    def test_get_product_list(self, base_info, testcase):
        """
        测试获取商品列表
        - 提取商品ID供后续接口使用
        """
        allure.dynamic.title(testcase['case_name'])
        RequestBase().specification_yaml(base_info, testcase)
    
    @allure.story(next(c_id) + "提交订单")
    @pytest.mark.run(order=2)
    @pytest.mark.parametrize('base_info,testcase',
        get_testcase_yaml('./testcase/ProductManager/commitOrder.yaml'))
    def test_commit_order(self, base_info, testcase):
        """
        测试提交订单
        - 使用商品列表接口返回的商品ID
        - 提取订单号供支付接口使用
        """
        allure.dynamic.title(testcase['case_name'])
        RequestBase().specification_yaml(base_info, testcase)
    
    @allure.story(next(c_id) + "订单支付")
    @pytest.mark.run(order=3)
    @pytest.mark.parametrize('base_info,testcase',
        get_testcase_yaml('./testcase/ProductManager/orderPay.yaml'))
    def test_order_pay(self, base_info, testcase):
        """
        测试订单支付
        - 使用提交订单返回的订单号
        - 验证支付结果
        """
        allure.dynamic.title(testcase['case_name'])
        RequestBase().specification_yaml(base_info, testcase)
```

**业务流程说明:**
```
商品列表 → 提交订单 → 订单支付
   ↓          ↓          ↓
提取商品ID  提取订单号   验证支付成功
   └──────────┴──────────┘
       参数自动传递
```

---

## 📊 测试执行与报告

### 1. 执行测试

```bash
# 执行所有测试
pytest testcase/ -vs

# 生成Allure报告
pytest testcase/ -vs --alluredir ./report/temp

# 查看Allure报告
allure serve ./report/temp
```

### 2. Allure报告展示

#### 报告概览
```
✅ 通过: 45
❌ 失败: 3
⚠️  跳过: 2
总计: 50
通过率: 90%
执行时长: 2.3分钟
```

#### 报告特性

| 特性 | 说明 |
|------|------|
| **测试套件分类** | 按模块展示用例(用户管理/商品管理) |
| **用例详情** | 显示请求参数、响应结果、断言信息 |
| **失败分析** | 详细的失败原因和堆栈信息 |
| **趋势图表** | 多次执行的通过率趋势 |
| **日志附件** | 请求日志、响应日志可直接查看 |

#### 环境配置

```xml
<?xml version="1.0" encoding="UTF-8"?>
<qa:environment xmlns:qa="urn:qatools:allure:environment">
    <n>测试环境</n>
    <value>http://127.0.0.1:8787</value>
    
    <n>测试人员</n>
    <value>Your Name</value>
    
    <n>Python版本</n>
    <value>3.8+</value>
    
    <n>项目名称</n>
    <value>电商平台接口自动化测试</value>
</qa:environment>
```

---

## ✨ 项目亮点总结

### 1. POM设计模式

**分层架构:**
- **用例层** (test_*.py): 定义测试场景,专注业务逻辑
- **驱动层** (apiutil.py): 封装请求处理、参数替换、断言逻辑
- **数据层** (*.yaml): 存储测试数据,实现用例与数据分离

**优势:**
- 代码复用性高,维护成本低
- 新增用例只需编写YAML配置,无需修改代码
- 驱动层变更不影响用例层

### 2. 数据驱动测试

**实现方式:**
- 使用 YAML 存储接口配置和测试数据
- 使用 `@pytest.mark.parametrize` 读取YAML数据
- 实现测试用例与测试数据的完全分离

**优势:**
- 非技术人员也能编写测试用例
- 新增用例只需添加YAML配置
- 测试数据可视化管理

### 3. 接口参数关联

**实现机制:**
- 接口A返回数据 → 自动提取关键参数 → 存储到extract.yaml
- 接口B使用 `${get_extract_data(key)}` 读取参数
- 支持JSONPath、正则表达式两种提取方式

**优势:**
- 无需手动传递参数,自动关联
- 支持复杂业务流程测试
- 参数可追溯,便于调试

### 4. 多维度断言

**断言类型:**
- **响应断言**: 验证返回数据的正确性
- **状态码断言**: 验证HTTP状态码
- **数据库断言**: 验证数据持久化

**优势:**
- 多维度保证接口质量
- 发现潜在的数据不一致问题
- 提升测试可靠性

### 5. 全流程业务测试

**业务场景:**
- 用户注册 → 登录 → 获取token → 新增/修改/删除用户
- 获取商品列表 → 提交订单 → 订单支付

**优势:**
- 验证完整业务链路
- 发现接口间的集成问题
- 更贴近真实用户场景

---

## 🎓 技术收获

- ✅ 掌握 Pytest 测试框架的高级用法(参数化、fixture、标记)
- ✅ 学会设计POM模式的自动化测试框架
- ✅ 理解接口测试的核心要素(请求、断言、参数关联)
- ✅ 掌握YAML数据驱动测试方法
- ✅ 熟悉Allure测试报告的配置与使用
- ✅ 了解SQLAlchemy进行数据库断言
- ✅ 实践CI/CD集成流程(Jenkins/Linux)

---

## 📚 相关资源

- [Pytest 官方文档](https://docs.pytest.org/)
- [Allure 官方文档](https://docs.qameta.io/allure/)
- [Requests 文档](https://requests.readthedocs.io/)
- [JSONPath 在线工具](http://www.atoolbox.net/Tool.php?Id=792)

---

<div align="center">

**⭐ 如果这个项目对你有帮助,欢迎Star支持 ⭐**

</div>